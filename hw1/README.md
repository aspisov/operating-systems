# Отчет по выполнению задания

**ФИО исполнителя:** Асписов Дмитрий Алексеевич

**Группа:** БПИ226

**Вариант задания:** 28

**Задание:** Разработать программу, которая определяет количество групп символов, интерпретируемые как шестнадцатеричные числа в ASCII–строке, и выводит не только количество таких чисел, но и сами числа, разделяя их запятыми.

**Тестирование:** все тесты и результаты тестов хранятся внутри директорий в формате `input.txt` и `output.txt`.

### Решение на 4 балла: Неименованные каналы (pipes)

- Использование неименованных каналов для односторонней связи между процессами.
- Основной процесс создает дочерний процесс с помощью `fork` и обменивается данными через `pipe`.
- Реализация предполагает выполнение всего процесса в рамках одного исполняемого файла.

### Инструкция по компиляции и запуску:

1. **Компиляция:**

   ```sh
   gcc -o hex_processor program.c
   ```

2. **Запуск:**

   Предполагается, что у вас есть текстовый файл `input.txt`, содержащий текст для обработки.

   ```sh
   ./hex_processor input.txt > output.txt
   ```
---
### Решение на 5 балла: Именованные каналы (FIFO)

- Программа чтения из файла и записи в FIFO.
- Программа обработки данных из FIFO и записи обработанных данных во второй FIFO.
- Программа чтения из второго FIFO и записи в выходной файл.

### Инструкция по компиляции и запуску

Прежде всего, необходимо создать два именованных канала (FIFO). Можно сделать это с помощью команды `mkfifo` в Linux из командной строки или в начале каждой программы, проверяя не был ли канал создан ранее.

```shell
mkfifo /tmp/fifo_reader_processor
mkfifo /tmp/fifo_processor_writer
```


Каждую программу (`reader.c`, `processor.c`, `writer.c`) следует компилировать отдельно, используя компилятор `gcc` или любой другой компилятор C, доступный в вашей системе.

```bash
gcc reader.c -o reader
gcc processor.c -o processor
gcc writer.c -o writer
```

Запускать программы нужно в следующем порядке, каждую в своем терминале или под процессом:

1. Запустите `writer`, указав выходной файл.
2. Запустите `processor`.
3. Запустите `reader`, указав входной файл.

Пример запуска:

```bash
./writer output.txt &
./processor &
./reader input.txt
```
---

### Решение на 6 балла: Двусторонняя связь через неименованные каналы

- Двусторонняя связь между родственными процессами с использованием пары неименованных каналов.
- Реализация обеспечивает обмен данными в обе стороны: от родительского к дочернему процессу и обратно.

### Инструкция по компиляции и запуску:

Сначала скомпилируйте программу с помощью компилятора `gcc`:

```sh
gcc parent_child.c -o parent_child
```

Затем запустите скомпилированную программу, указав в качестве аргументов путь к входному и выходному файлам:

```sh
./parent_child input.txt output.txt
```

Где `input.txt` — это файл, содержащий исходные данные, которые будут обработаны (например, текст с шестнадцатеричными и другими символами), а `output.txt` — это файл, куда будут записаны найденные шестнадцатеричные числа.

---
### Решение на 7 балла: Двусторонняя связь через именованные каналы (FIFO)

- Использование двух именованных каналов для реализации двусторонней связи между двумя независимыми процессами.
- Программы взаимодействуют через FIFO, обмениваясь данными для обработки и получения результатов.

### Инструкции по компиляции и запуску

1. Скомпилируйте обе программы отдельно, используя `gcc` или другой компилятор C:

```sh
gcc reader_writer_fifo.c -o reader_writer_fifo
gcc processor_fifo.c -o processor_fifo
```

2. Убедитесь, что именованные каналы (FIFO) созданы. Если нет, создайте их с помощью команды `mkfifo`:

```sh
mkfifo /tmp/fifo_to_processor
mkfifo /tmp/fifo_from_processor
```

3. Запустите обе программы. Сначала запустите `processor_fifo`, а затем `reader_writer_fifo`, передав имя входного файла и имя выходного файла в качестве аргументов:

```sh
./processor_fifo &
./reader_writer_fifo input.txt output.txt
```


---
### Решение на 8 балла: Почастичная передача данных через именованные каналы (FIFO)

- Аналогично решению на 7 балла, но с акцентом на многократную почастичную передачу данных через FIFO, учитывая ограничения буфера.
- Демонстрируется способность системы к обработке больших объемов данных, передаваемых по частям.

### Инструкции по компиляции и запуску

1. Скомпилируйте обе программы отдельно:

```sh
gcc requester.c -o requester
gcc processor.c -o processor
```

2. Убедитесь, что именованные каналы (FIFO) созданы. Если нет, создайте их с помощью команды `mkfifo`:

```sh
mkfifo /tmp/fifo_request
mkfifo /tmp/fifo_response
```

3. Запустите обе программы. Сначала запустите `processor`, а затем `requester`, передав имя входного файла и имя выходного файла в качестве аргументов:

```sh
./processor &
./requester input.txt output.txt
```

---
### Решение на 9 балла: Передача данных через очереди сообщений (message queues)

- Использование очередей сообщений для взаимодействия между двумя независимыми процессами.
- Обеспечивается возможность асинхронного обмена сообщениями, содержащими данные для обработки и результаты обработки.

### Инструкция по компиляции и запуску

1. Компиляция программ:
   ```sh
   gcc sender.c -o sender
   gcc processor.c -o processor
   ```
2. Запуск `processor` и `sender` с указанием входного файла:
   ```sh
   ./processor & ./sender input.txt
   ```


---
### Решение на 10 балла: Многократная передача данных через очереди сообщений

- Расширение решения на 9 балла с реализацией механизма для многократной передачи и обработки данных через очереди сообщений.
- Программы организуют непрерывный обмен данными, разбивая передачу на множество операций чтения/записи в очередь.

### Компиляция и запуск

1. Скомпилируйте обе программы:

```sh
gcc sender_receiver.c -o sender_receiver
gcc processor.c -o processor
```

2. Запустите сначала `processor`, а затем `sender_receiver`, указав пути к входному и выходному файлам:

```sh
./processor &
./sender_receiver input.txt output.txt
```
