# Домашнее задание 2: Bash Скрипты
Ниже представлены 10 мини-скриптов на Bash, 
первые 6 из них можно запустить написав `bash имяфайла.sh` в терминал из этой директории.
Остальные 4 представлены только в виде кода внутри этого `.md` файла, 
так как они могут модифицировать данные на вашем ПК, запуск проводите на свой страх и риск,
предварительно ознакомившись с описанием к скриптам и их содержимым.

## Скрипт 1: Проверка Существования Директории
Этот скрипт проверяет, существует ли определенная директория в файловой системе.

```bash
# Этот скрипт проверяет существование указанной директории.

echo "Введите директорию, которую хотите проверить:"
read dir

if [ -d "$dir" ]; then
    echo "Директория $dir существует."
else
    echo "Директория $dir не существует."
fi
```

## Скрипт 2: Перечисление Файлов до Нахождения
Этот скрипт перечисляет файлы в текущей директории и останавливается, когда находит файл, указанный пользователем.

```bash
# Этот скрипт перечисляет файлы в текущей директории до нахождения определенного файла.

echo "Введите имя файла, который вы ищете:"
read target_file

echo "Ищем $target_file в текущей директории..."
for file in $(ls -1); do
    echo "Найден файл: $file"
    if [ "$file" == "$target_file" ]; then
        echo "$target_file найден."
        break
    fi
done
```

## Скрипт 3: Ожидание Пустоты Директории
Этот скрипт периодически проверяет, пуста ли указанная директория, и ждет ее пустоты перед завершением.

```bash
# Этот скрипт ожидает, пока указанная директория не станет пустой.

echo "Введите директорию, за пустотой которой хотите наблюдать:"
read dir

echo "Ожидаем, пока $dir станет пустой..."
while [ "$(ls -A "$dir")" ]; do
    echo "$dir еще не пуста."
    sleep 5 # Ждем 5 секунд перед следующей проверкой
done
echo "$dir теперь пуста."
```

## Скрипт 4: Подсчет Количества Директорий
Этот скрипт считает количество директорий в текущей директории.

```bash
# Этот скрипт подсчитывает количество директорий в текущей директории.

count=0 # Счетчик директорий

for dir in */; do
    if [ -d "$dir" ]; then
        count=$((count + 1)) # Увеличиваем счетчик для каждой директории
    fi
done

echo "В текущей директории $count директорий."
```

## Скрипт 5: Печать Файла с Номерами Строк
Этот скрипт выводит содержимое файла, добавляя номера строк к каждой строке.

```bash
# Этот скрипт выводит строки файла с номерами перед каждой строкой.

echo "Введите имя файла для печати с номерами строк:"
read file

line_number=1 # Счетчик номеров строк

while IFS= read -r line; do
    echo "$line_number: $line" # Печать номера строки и текста строки
    line_number=$((line_number + 1)) # Увеличение номера строки
done < "$file"
```

## Скрипт 6: Игра "Угадай число"
Этот скрипт реализует игру "Угадай число". В нём определена функция `generate_number` для создания случайного числа, которое пользователь должен угадать. Функция `prompt_guess` предназначена для получения догадки пользователя из стандартного ввода. Функция `play_game` содержит цикл `while`, который повторно вызывает `prompt_guess` и использует условные операторы `if` для предоставления обратной связи пользователю, пока не будет угадано правильное число.

```bash
# Этот скрипт - простая игра "Угадай число".

# Функция, генерирующая случайное число от 1 до 100
generate_number() {
  echo $(( (RANDOM % 100) + 1 ))
}

# Функция для предложения пользователю угадать число
prompt_guess() {
  echo "Угадайте число от 1 до 100"
  read guess
}

# Основной игровой цикл
play_game() {
  local target=$(generate_number)
  local guess=-1
  
  # Продолжаем предлагать пользователю угадать число, пока не будет угадано правильное
  while [[ $guess -ne $target ]]; do
    prompt_guess
    
    # Проверяем, правильно ли угадано число
    if [[ $guess -eq $target ]]; then
      echo "Поздравляем! Вы угадали правильное число: $target"
      break
    elif [[ $guess -lt $target ]]; then
      echo "Больше!"
    else
      echo "Меньше!"
    fi
  done
}

# Начало игры
play_game
```

# ОСТОРОЖНО!
Скрипты ниже изменяют/модифицируют данные на вашем ПК, поэтому файлы к ним не приведены и запуск производится на свой страх и риск.

## Скрипт 7: Очистка Директории
Этот скрипт помогает в очистке директории, удаляя файлы, которые не использовались более 30 дней. Функция `list_files` перечисляет все файлы в текущей директории. Функция `is_old_file` проверяет, является ли файл старше 30 дней, используя команду `find`. Функция `clean_directory` содержит цикл `while`, который вызывает `is_old_file` и использует условие `if` для удаления старых файлов.

```bash
# Этот скрипт - простой очиститель директории.

# Функция, которая перечисляет файлы в директории
list_files() {
  echo "Перечисление всех файлов в директории:"
  ls
}

# Функция, проверяющая, не был ли файл использован более 30 дней
is_old_file() {
  local file=$1
  if [[ $(find "$file" -type f -atime +30 2>/dev/null) ]]; then
    return 0 # Файл старше 30 дней
  else
    return 1 # Файл не старше 30 дней
  fi
}

# Функция для очистки старых файлов в текущей директории
clean_directory() {
  # Перебираем каждый файл в текущей директории
  local file
  while IFS= read -r -d '' file; do
    # Проверяем, не использовался ли файл более 30 дней
    if is_old_file "$file"; then
      echo "Удаление старого файла: $file"
      rm "$file" # Удаляем файл
    else
      echo "Оставляем файл: $file"
    fi
  done < <(find . -maxdepth 1 -type f -print0)
}

# Перечисляем файлы до очистки
list_files
# Очищаем директорию от старых файлов
clean_directory
# Перечисляем файлы после очистки, чтобы показать результат
list_files
```

## Скрипт 8: Утилита для Резервного Копирования
Этот скрипт - утилита для резервного копирования, которая сжимает указанные директории в архивные файлы tarball. Функция `create_backup` принимает путь к директории и создает сжатый tarball. Функция `check_disk_space` определяет, достаточно ли места на диске для выполнения резервного копирования. Функция `backup_directories` итерируется по списку директорий в цикле `while` и использует оператор `if` для принятия решения о резервном копировании каждой директории на основе доступного дискового пространства.

```bash
# Этот скрипт - простая утилита для резервного копирования.

# Функция, сжимающая файлы в директории в tarball
create_backup() {
  local directory=$1
  local timestamp=$(date +%Y%m%d%H%M%S)
  local backup_filename="backup_${directory//\//_}_$timestamp.tar.gz"
  
  echo "Создание резервной копии для $directory"
  tar -czf "$backup_filename" "$directory" && echo "Резервная копия создана: $backup_filename"
}

# Функция для проверки достаточности дискового пространства для резервного копирования
check_disk_space() {
  local required_space=$1
  local available_space=$(df . | tail -1 | awk '{print $4}')
  
  if [[ $available_space -lt $required_space ]]; then
    echo "Недостаточно места на диске для резервного копирования. Необходимо: $required_space, Доступно: $available_space"
    return 1
  else
    echo "Достаточно места на диске для резервного копирования. Продолжаем..."
    return 0
  fi
}

# Функция для резервного копирования нескольких директорий
backup_directories() {
  local directories=("$@")
  local dir
  local required_space=50000 # Пример необходимого пространства для каждой резервной копии

  # Итерация по списку директорий
  for dir in "${directories[@]}"; do
    echo "Проверка директории: $dir"
    
    # Проверяем, достаточно ли дискового пространства
    if check_disk_space "$required_space"; then
      create_backup "$dir"
    else
      echo "Пропуск резервного копирования для $dir из-за недостатка дискового пространства."
    fi
  done
}

# Пример директорий для резервного копирования
directories_to_backup=('/etc' '/var/log')

# Начало процесса резервного копирования
backup_directories "${directories_to_backup[@]}"
```

## Скрипт 9: Утилита Управления Пользователями
Этот скрипт управляет пользователями в системе, добавляя или удаляя их. Функция `add_user` добавляет нового пользователя, если он еще не существует. Функция `delete_user` удаляет пользователя, если он существует. Функция `manage_users` обрабатывает список действий с пользователями с помощью цикла `while`, используя условные операторы `if` для определения правильного действия для каждого пользователя.

```bash
# Этот скрипт - простая утилита управления пользователями.

# Функция для добавления нового пользователя в систему
add_user() {
  local username=$1
  if id "$username" &>/dev/null; then
    echo "Пользователь $username уже существует."
  else
    echo "Добавление пользователя $username."
    sudo useradd "$username" && echo "Пользователь $username успешно добавлен."
  fi
}

# Функция для удаления пользователя из системы
delete_user() {
  local username=$1
  if id "$username" &>/dev/null; then
    echo "Удаление пользователя $username."
    sudo userdel "$username" && echo "Пользователь $username успешно удален."
  else
    echo "Пользователь $username не существует."
  fi
}

# Функция для обработки списка действий с пользователями
manage_users() {
  local user_actions=("$@")
  local action username

  # Итерация по списку действий с пользователями
  while [[ ${#user_actions[@]} -gt 0 ]]; do
    action=${user_actions[0]}
    username=${user_actions[1]}
    user_actions=("${user_actions[@]:2}")

    # Определяем действие для каждого пользователя
    if [[ $action == "add" ]]; then
      add_user "$username"
    elif [[ $action == "delete" ]]; then
      delete_user "$username"
    else
      echo "Неверное действие: $action для пользователя $username."
    fi
  done
}

# Пример действий с пользователями для обработки
user_actions=('add' 'john' 'delete' 'doe' 'add' 'jane')

# Начало процесса управления пользователями
manage_users "${user_actions[@]}"
```

## Скрипт 10: Инструмент Мониторинга Диска
Этот скрипт осуществляет мониторинг использования дискового пространства и отправляет предупреждения, если использование превышает определенный порог. Функция `check_disk_usage` получает текущий процент использования дискового пространства. Функция `send_alert` проверяет, превышает ли использование 90% и отправляет предупреждающее сообщение. Функция `monitor_disk` содержит бесконечный цикл `while`, который регулярно проверяет использование диска через установленные интервалы, используя оператор `if` в `send_alert` для определения момента отправки предупреждения.

```bash
# Этот скрипт - простой инструмент мониторинга диска.

# Функция для проверки текущего процента использования дискового пространства
check_disk_usage() {
  df -h | grep -E '^/dev/' | awk '{ print $5 " " $1 }'
}

# Функция для отправки предупреждения, если использование диска превышает порог
send_alert() {
  local disk_usage=$1
  local partition=$2
  local usage_percentage=${disk_usage%?}
  
  if [[ $usage_percentage -ge 90 ]]; then
    echo "Предупреждение: Высокое использование диска для $partition: $disk_usage"
    # В реальной ситуации здесь можно было бы отправить настоящее предупреждение, например, через электронную почту или системное уведомление.
  fi
}

# Функция для непрерывного мониторинга использования диска
monitor_disk() {
  local interval=${1:-60} # По умолчанию 60 секунд, если интервал не указан
  
  # Бесконечный цикл while для мониторинга использования диска
  while true; do
    local usage_info=($(check_disk_usage))
    local partition_usage=${usage_info[0]}
    local partition_name=${usage_info[1]}

    # Активация предупреждения в зависимости от использования диска
    send_alert "$partition_usage" "$partition_name"
    
    sleep "$interval"
  done
}

# Начало процесса мониторинга диска с интервалом в 120 секунд
monitor_disk 120
```

